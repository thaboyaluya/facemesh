<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Password</title>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.11.9/p5.min.js"></script>
    <script src="https://unpkg.com/ml5@1/dist/ml5.min.js"></script>
</head>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif; display:flex; gap:16px; padding:12px; }
    #canvasContainer { position:relative; }
    canvas { border-radius:8px; box-shadow: 0 6px 18px rgba(0,0,0,0.12); }
    #ui { max-width:360px; }
    #status { font-size:18px; margin:6px 0; }
    .small { font-size:13px; color:#555; }
    button { padding:8px 12px; border-radius:8px; border:1px solid #ddd; cursor:pointer; }
    pre { background:#f7f7f7; padding:8px; border-radius:6px; overflow:auto; max-height:200px; }
  </style>
<body>
  <div id="canvasContainer">
    <!-- p5 will create the canvas here -->
  </div>

  <div id="ui">
    <h3>Multi-Gesture Login</h3>
    <div id="status">Waiting for model to load...</div>
    <div class="small" id="instructions">Sequence: <b>Blink twice â†’ Smile â†’ Tilt head left</b></div>
    <div style="margin-top:10px;">
      <button id="startBtn">Start / Recalibrate</button>
      <button id="resetBtn">Reset</button>
    </div>

    <h4 style="margin-top:18px;">Debug values</h4>
    <pre id="debug">loading...</pre>

    <p class="small">Notes: Serve this page from <b>https</b> or run on <b>localhost</b>. If tilt direction is inverted for you, small threshold tweak is below.</p>
  </div>

  <script>
    // --- CONFIG ---
    const CALIBRATION_FRAMES = 100;            // frames used to record baseline eye-open ratio
    const BLINKS_REQUIRED = 2;                 // number of blinks required
    const STEP_TIMEOUT_MS = 10000;             // max time allowed per step
    const SMILE_RATIO_THRESHOLD = 0.43;        // mouthWidth / faceWidth threshold to detect smile (tunable)
    const TILT_ANGLE_THRESHOLD_DEG = -10;      // negative = left head tilt (tunable)
    // ----------------

    let video, facemesh;
    let predictions = [];
    let canvasContainer;

    // calibration & detection state
    let calibrationSamples = [];
    let blinkThreshold = null; // determined after calibration
    let frameCountSinceCal = 0;
    let isCalibrating = false;

    let blinkCount = 0;
    let closedPrev = false;
    let lastBlinkTime = 0;

    // state machine: 0 = blink step, 1 = smile, 2 = tilt, 3 = success
    let step = 0;
    const stepNames = ['Blink x2', 'Smile', 'Tilt left'];

    let stepStartTime = 0;
    let loggedIn = false;

    // p5 setup
    function setup() {
      canvasContainer = document.getElementById('canvasContainer');
      const cnv = createCanvas(640, 480);
      cnv.parent('canvasContainer');

      video = createCapture(VIDEO, () => {});
      video.size(width, height);
      video.hide();

      // load facemesh
      facemesh = ml5.facemesh(video, () => {
        console.log('FaceMesh model ready');
        document.getElementById('status').innerText = 'Model loaded â€” press Start / Recalibrate';
      });
      facemesh.on('predict', results => predictions = results);

      // UI buttons
      document.getElementById('startBtn').addEventListener('click', () => startCalibration());
      document.getElementById('resetBtn').addEventListener('click', () => resetFlow());
    }

    function draw() {
      background(30);
      if (video) image(video, 0, 0, width, height);

      // draw keypoints if we have a face
      if (predictions.length > 0) {
        drawKeypoints(predictions[0].scaledMesh);
      }

      // handle flow
      if (isCalibrating) {
        runCalibration();
      } else if (!loggedIn && blinkThreshold !== null) {
        runStateMachine();
      }

      // Debug panel
      renderDebug();
    }

    // draw small points for landmarks (lighter)
    function drawKeypoints(keypoints) {
      noStroke();
      fill(0, 255, 150, 160);
      for (let i = 0; i < keypoints.length; i+=2) { // draw subset for speed
        const [x, y] = keypoints[i];
        ellipse(x, y, 3, 3);
      }
    }

    // -----------------------
    // KEY DETECTION HELPERS
    // -----------------------

    // compute a robust eye ratio using multiple landmarks:
    // we take the min/max x and y inside a group and return height/width (vertical span over horizontal span)
    function regionRatio(keypoints, indices) {
      const xs = indices.map(i => keypoints[i][0]);
      const ys = indices.map(i => keypoints[i][1]);
      const w = Math.max(...xs) - Math.min(...xs);
      const h = Math.max(...ys) - Math.min(...ys);
      if (w === 0) return 0;
      return h / w;
    }

    // left & right eye index groups (MediaPipe FaceMesh landmarks)
    const LEFT_EYE_IDX = [33, 160, 158, 133, 153, 144, 163, 7];
    const RIGHT_EYE_IDX = [362, 385, 387, 263, 373, 380, 390, 249];

    // mouth landmarks (outer corners + top/bottom)
    const LEFT_MOUTH = 61, RIGHT_MOUTH = 291, TOP_LIP = 13, BOTTOM_LIP = 14;

    // cheeks for face width
    const LEFT_CHEEK = 234, RIGHT_CHEEK = 454;

    // nose tip for extra diagnostics (optional)
    const NOSE = 1;

    function avgEyeRatio(keypoints) {
      const left = regionRatio(keypoints, LEFT_EYE_IDX);
      const right = regionRatio(keypoints, RIGHT_EYE_IDX);
      return (left + right) / 2;
    }

    function faceWidth(keypoints) {
      return distPoints(keypoints[LEFT_CHEEK], keypoints[RIGHT_CHEEK]);
    }

    function mouthWidthAndHeight(keypoints) {
      const lw = keypoints[LEFT_MOUTH], rw = keypoints[RIGHT_MOUTH];
      const top = keypoints[TOP_LIP], bottom = keypoints[BOTTOM_LIP];
      const w = distPoints(lw, rw);
      const h = distPoints(top, bottom);
      return { w, h };
    }

    function distPoints(a, b) {
      const dx = a[0] - b[0];
      const dy = a[1] - b[1];
      return Math.sqrt(dx*dx + dy*dy);
    }

    // compute roll angle (degrees) using centers of eye regions
    function eyeRollDegrees(keypoints) {
      const leftPts = LEFT_EYE_IDX.map(i => keypoints[i]);
      const rightPts = RIGHT_EYE_IDX.map(i => keypoints[i]);

      const leftCenter = meanPoint(leftPts);
      const rightCenter = meanPoint(rightPts);

      const dx = rightCenter[0] - leftCenter[0];
      const dy = rightCenter[1] - leftCenter[1];
      const rad = Math.atan2(dy, dx);
      return rad * (180 / Math.PI); // degrees
    }

    function meanPoint(pts) {
      let sx = 0, sy = 0;
      for (const p of pts) { sx += p[0]; sy += p[1]; }
      return [sx/pts.length, sy/pts.length];
    }

    // -----------------------
    // CALIBRATION
    // -----------------------
    function startCalibration() {
      calibrationSamples = [];
      isCalibrating = true;
      frameCountSinceCal = 0;
      document.getElementById('status').innerText = 'Calibrating â€” please look at camera with eyes open...';
    }

    function runCalibration() {
      frameCountSinceCal++;
      if (predictions.length > 0) {
        const kp = predictions[0].scaledMesh;
        const r = avgEyeRatio(kp);
        if (r > 0) calibrationSamples.push(r);
      }

      // after enough frames, compute median and set threshold
      if (calibrationSamples.length >= CALIBRATION_FRAMES) {
        calibrationSamples.sort((a,b) => a-b);
        const median = calibrationSamples[Math.floor(calibrationSamples.length/2)];
        blinkThreshold = median * 0.55; // eyes closed when ratio drops below ~55% of open median
        isCalibrating = false;
        step = 0;
        blinkCount = 0;
        closedPrev = false;
        loggedIn = false;
        stepStartTime = millis();
        document.getElementById('status').innerText = 'Calibrated. Perform: Blink twice â†’ Smile â†’ Tilt left';
      } else {
        // show progress
        document.getElementById('status').innerText = `Calibrating... (${calibrationSamples.length}/${CALIBRATION_FRAMES})`;
      }
    }

    // -----------------------
    // STATE MACHINE
    // -----------------------
    function runStateMachine() {
      if (millis() - stepStartTime > STEP_TIMEOUT_MS) {
        // timed out waiting for the current step -> reset to start
        document.getElementById('status').innerText = 'Timeout â€” sequence reset. Start again.';
        resetFlow();
        return;
      }

      if (predictions.length === 0) {
        document.getElementById('status').innerText = 'No face detected â€” please face the camera';
        return;
      }

      const kp = predictions[0].scaledMesh;
      if (step === 0) {
        // BLINK step: require BLINKS_REQUIRED blinks
        detectBlink(kp);
        document.getElementById('status').innerText = `Step: Blink Ã—${BLINKS_REQUIRED} (${blinkCount}/${BLINKS_REQUIRED})`;
      } else if (step === 1) {
        // SMILE step
        if (detectSmile(kp)) {
          step = 2;
          stepStartTime = millis();
          document.getElementById('status').innerText = 'âœ… Smile detected. Now tilt head left';
        } else {
          document.getElementById('status').innerText = 'Step: Smile â€” please smile';
        }
      } else if (step === 2) {
        // TILT step
        if (detectTiltLeft(kp)) {
          step = 3;
          loggedIn = true;
          document.getElementById('status').innerText = 'ðŸŽ‰ Login Successful!';
        } else {
          document.getElementById('status').innerText = 'Step: Tilt â€” tilt your head left';
        }
      }
    }

    function detectBlink(kp) {
      const r = avgEyeRatio(kp);

      // closed detection with edge (rising) detection
      const closedNow = (blinkThreshold !== null) && (r < blinkThreshold);

      if (closedNow && !closedPrev) {
        // closure started -> count 1 blink
        const now = millis();
        // debounce: ensure not counting very rapid frames as multiple blinks
        if (now - lastBlinkTime > 200) {
          blinkCount++;
          lastBlinkTime = now;
        }
      }
      closedPrev = closedNow;

      // if required number reached -> go to next step
      if (blinkCount >= BLINKS_REQUIRED) {
        step = 1;
        stepStartTime = millis();
        document.getElementById('status').innerText = 'âœ… Blink done! Now smile';
      }
    }

    function detectSmile(kp) {
      const {w: mW, h: mH} = mouthWidthAndHeight(kp);
      const fW = faceWidth(kp) || 1;
      const mouthWidthNorm = mW / fW;

      // simple rule: mouth becomes comparatively wide on smile
      if (mouthWidthNorm > SMILE_RATIO_THRESHOLD) return true;
      return false;
    }

    function detectTiltLeft(kp) {
      const roll = eyeRollDegrees(kp); // degrees
      // debug: you might find your camera/pose gives inverted sign â€” adjust sign or threshold accordingly
      if (roll < TILT_ANGLE_THRESHOLD_DEG) return true;
      return false;
    }

    function resetFlow() {
      blinkCount = 0;
      closedPrev = false;
      step = 0;
      loggedIn = false;
      stepStartTime = millis();
      document.getElementById('status').innerText = 'Sequence reset. Press Start / Recalibrate';
    }

    // -----------------------
    // UI DEBUG
    // -----------------------
    function renderDebug() {
      const d = document.getElementById('debug');
      if (predictions.length === 0) {
        d.innerText = 'No face detected';
        return;
      }
      const kp = predictions[0].scaledMesh;
      const r = avgEyeRatio(kp);
      const {w: mW, h: mH} = mouthWidthAndHeight(kp);
      const fW = faceWidth(kp);
      const roll = eyeRollDegrees(kp);

      d.innerText =
`step: ${step} (${stepNames[step] || 'done'})
blinkThreshold: ${blinkThreshold ? blinkThreshold.toFixed(4) : 'not set'}
eyeRatio(avg): ${r.toFixed(4)}
blinkCount: ${blinkCount}
mouthWidth: ${mW.toFixed(1)}  mouthHeight: ${mH.toFixed(1)}  -> mouthWidth/faceWidth: ${(mW/fW).toFixed(3)}
faceWidth: ${fW.toFixed(1)}
roll (deg): ${roll.toFixed(2)}  (tilt left <= ${TILT_ANGLE_THRESHOLD_DEG}Â°)
loggedIn: ${loggedIn}
instructions: Blink twice â†’ Smile â†’ Tilt head left
`;
    }

    // small helper for p5 to use millis()
    function millis() {
      return Date.now() - startTime;
    }

    // track start time for our millis()
    let startTime = Date.now();

  </script>
</body>
</html>